---
title: C# WeakReference弱引用
date: 2022-04-17 21:24:36
tags:
  - C#
  - .Net
---

## 什么是弱引用
弱引用是区别于我们通常是所说的“引用”的一种说法。一般来说 ，如果一个对象当前仍存在对其的引用，则GC不会作为垃圾将其回收，这就是所谓的“强”的概念。而区别于这种“强”，弱引用的特点是在引用对象的同时，允许回收该对象。


弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。基于这样的设定，**一定要注意的是，弱引用的生命周期仅限于GC回收垃圾前的一段不确定的事件段内**。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。

```csharp
WeakReference w = new WeakReference(xml);   // 创建若引用对象
if (w.IsAlive)  // 判断是否已被垃圾回收
{
    XmlDocument xml1 = w.Target as XmlDocument; // 转换为指定的对象类型给你}
}
```
上面就是弱引用的常用写法。任何对象都可以包含在WeakReference中以弱引用方式保留。但是在下一次从弱引用中获取相应实例的时候需要先判断IsAlive是否为true以及Target是否还存在。因为弱引用对垃圾回收的许可，使用的时候也许已经被回收掉了，所以必须对其先进行判断。
## 短弱引用与长弱引用
WeakReference分为长短两种弱引用方式，这在WeakReference构造函数中有所体现：
```csharp
public WeakReference(object? target, bool trackResurrection)
```
第二个参数即为用来指示何时停止跟踪对象，如果为true，指定为长弱引用模式，默认为短弱引用模式。
短弱引用中，在GC回收对象后，Target即变为null；而在长弱引用模式下，对Target的跟踪则直到对象的Finalize方法调用后才不再可以使用。但需要注意的是，在Fianlize执行前，也许对象中的某些成员已经被回收，所以，对于长弱引用的使用需要十分小心。**长弱引用只针对包含Finalize函数的对象，如果不存在仍为短弱引用**。
> 由于垃圾回收的机制，包含Finalize的对象，需要至少两次回收才能真正释放其资源。
> 概括而言，就是将垃圾回收分为了三个阶段，第一个阶段回收没有Finalize方法或者析构函数的对象，第二个阶段调用那些析构函数或者Finalize方法，第三个阶段回收那些刚调用了析构函数或者Finalize方法的对象。

## 使用原则

* 仅在必要时使用长弱引用，因为在终结后对象的状态不可预知。
* 避免对小对象使用弱引用，因为指针本身可能和对象一样大，或者比对象还大。
* 避免将弱引用作为内存管理问题的自动解决方案， 而应开发一个有效的缓存策略来处理应用程序的对象。

